<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Be a Cool hacker]]></title>
  <link href="http://flowkater.github.io/atom.xml" rel="self"/>
  <link href="http://flowkater.github.io/"/>
  <updated>2015-03-19T18:43:55+09:00</updated>
  <id>http://flowkater.github.io/</id>
  <author>
    <name><![CDATA[Fl0wk27er]]></name>
    <email><![CDATA[chjw102@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[높은 완성도의 안드로이드 앱 개발하기- 기획, 기술, 개발 편]]></title>
    <link href="http://flowkater.github.io/blog/2014/03/18/maso-android-profiler/"/>
    <updated>2014-03-18T23:31:00+09:00</updated>
    <id>http://flowkater.github.io/blog/2014/03/18/maso-android-profiler</id>
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;<a href="http://flowkater.github.io/blog/2014/03/04/review-jco-team-speech/">JCO 후기 글</a>을 쓰면서, 그리고 발표를 하면서 <a href="http://www.imaso.co.kr/">마이크로소프트웨어</a> 잡지에 안드로이드 성능 분석 관련한 글을 기고했다고 말씀드렸습니다.</p>

<p><img src="http://imageshack.com/a/img196/8651/naok.png" alt="제목" /></p>

<!-- more -->


<p>&nbsp;&nbsp;저희 글 뿐만 아니라 개발 트렌드나 도움되는 정보들이 많으니 개발자분들은 꼭 구독하시면 좋을 것 같습니다. 1월부터 저희가 높은 완성도의 안드로이드 앱 개발하기 Cerberus 프로젝트 기획, 기술, 개발 세 편으로 3월까지 기고한 글을 공유합니다.</p>

<p>&nbsp;&nbsp;어떻게, 어떤 방법으로 기획하였는지, 기존의 안드로이드, 자바 기술, 저희가 개발할 때 활용한 부분까지 총망라해서 적었습니다. 참고해보시고 궁금한 사항이 있으면 질문주시면 좋겠네요.</p>

<p>&nbsp;&nbsp;ps: <a href="http://goo.gl/te1b6a">http://goo.gl/te1b6a</a> 에서 설문을 참여해주시면 정말 감사하겠습니다.</p>

<p>&nbsp;&nbsp;자료 다운받기 <a href="http://goo.gl/0js7uR">http://goo.gl/0js7uR</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[방황하는 대학생 프로그래머에게 필요한 것..?]]></title>
    <link href="http://flowkater.github.io/blog/2014/03/18/soma-be-a-programmer-to-student/"/>
    <updated>2014-03-18T23:09:00+09:00</updated>
    <id>http://flowkater.github.io/blog/2014/03/18/soma-be-a-programmer-to-student</id>
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;사실 이 글은 소프트웨어 마에스트로 과정에 대해서 조언을 구하는 후배에게 썼던 메일 내용입니다. 다시 읽어도 졸문이지만.. 처음 시작하시는 분들에게 혹시 도움이 될까 싶어서 제 블로그에도 담아 보려합니다.</p>

<p>&nbsp;&nbsp;아래는 원문입니다.</p>

<p><img src="http://imageshack.com/a/img829/4720/c849.jpg" alt="Programmer??" /></p>

<!-- more -->


<p><small>13학번 OOO군이 간략한 자기소개를 보내주셔서 썼는데 이게 OO군 말고도 해당되시는 분이 있을 것 같애서 졸문이지만 공유하면 좋을 것 같아서 여기다가 올립니다. 개인적인 사견이 많이 들어갔으니 우리 실력있는 선배들은 무시해주시구요. 다들 잘하시니까 ^^ 저학년 후배님들은 한번 읽어보셔도 좋을것 같습니다.</p>

<p>===============================================</p>

<p>안녕하세요. flowkater입니다.</p>

<p>소프트웨어 마에스트로를 떠나서 본인이 실질적인 조언을 구하니 일단 현실적으로 말씀드릴게요.</p>

<p>일단 스터디, 세미나에 단순히 참여하는 것은 본인 이력에 전혀 도움이 안됩니다.(공부는 되겠죠. 여기서 말하는 건 눈에 보이는 커리어입니다.) 본인이 직접 커뮤니티를 운영했다거나 큰 컨퍼런스에서 직접 발표하는게 아닌 이상 제 3자가 보기엔 아무것도 안한것과 다름없죠. 해킹대회? 입상안하면 아무 도움 안됩니다. <strong>(동아리가 보안동아리입니다.)</strong></p>

<p>또한, 프로젝트를 하지 못했다는 것은 본인의 관심사가 과연 컴퓨터 공학인가, 그냥 롤모델이 멋있어서 쫓아오지 않았나 등에 대해서 진지하게 고민해야되지 않나 싶습니다.</p>

<p>컴퓨터 공학과는 나와도 그만 안나와도 그만인 전공입니다. 실무에서 필요한 기술만 배워서 취업하려면 충분히 가능하지요. 오히려 그 시간에 다른 전공을 공부하고 프로그래밍 하는 친구들 보다 경쟁력이 떨어집니다. 그게 현실입니다. <strong>(논란이 있는 부분이지만 컴퓨터 공학 전공이면서도 프로그래밍을 잘 못하는 친구들에게 강하게 말하려다보니 이렇게 쓰게 됬네요)</strong></p>

<p>제가 이렇게 까지 말씀드리는 건 모든 곳에서(어떤 곳이든) 지원 당사자에게 열정을 봅니다. 기술도 좋고 머리가 좋은 것도 좋지만 열정을 봅니다. 컴퓨터 공학에서 열정이란 무엇일까요?</p>

<p>바로 자기 스스로 커뮤니티를 조직하고 공부한 것을 많은 사람들에게 공유하고 자기가 니즈를 느낀 부분에 대해서 문제를 풀어보고자 프로젝트를 진행하는 것입니다.</p>

<p>빌게이츠, 스티브 잡스, 마크 주커버그 등 그들이 진정 프로그래머이든 아니든 간에 그들은 그들 스스로 문제를 발견하고 그걸 해결하고자 무언가를 만들려고 했던 사람입니다.</p>

<p>무조건 열심히 하겠습니다. 최선을 다하겠습니다. 라는 말은 본인이 생각하기에도 신뢰성이 떨어진다는 걸 더 잘 느낄 것입니다.</p>

<p>해커로서 앞으로 인생을 살아나갈 생각이라면 조금 더 진지하게 생각해야될 부분이 있어 보입니다. 내가 진정, 정말로 이걸 좋아하고 즐기는지. 그리고 그게 맞다면 끈기있게 해나가면 됩니다.</p>

<p>개인적인 얘기를 드리면 저는 군대 제대할때까지 (23살까지) 프로그래밍 한 번 제대로 안해본 사람이었고(1학년때 C언어 F 였습니다.) 막연한 꿈만 좇아서 제대후 보안을 하고 싶다고 공부를 했지만 만족스럽게 하지 못했죠.</p>

<p>왜냐면 저는 저를 파악하고 제가 원하는 걸 한게 아니고 그냥 단순히 해킹이 멋잇어 보이고 먼가 유망하다는 말만 듣고 시작을 했던 것입니다. 잘될 일이 없겠죠.</p>

<p>그러다가 우연히 웹 개발을 접하게 됬고 제 스스로 기획하고 디자인하고 서비스를 런칭해보았습니다. 순수 제 힘이었고 처음보는 언어, 처음보는 프레임워크, 처음 개발해보는 웹이었습니다. 그리고 제가 만든 걸 사람들이 쓰는 걸 보았죠.</p>

<p>전 거기서 순수한 제 흥미를 느꼈습니다. 그리고 정말 가치있는 것을 사람들에게 전달한다는게 너무 좋았고 소프트웨어 개발이 마법 같아 보였습니다.</p>

<p>그때 이후로 두 번의 창업, 스타트업 조인, 해커톤 우승, 소프트웨어 마에스트로 등 생각지도 못한 커리어를 밟고 있습니다.</p>

<p>제 자랑을 하려는 게 아니고 제 말인 즉슨, 본인 스스로를 제대로 파악해야된다는 말이죠. 그런데 그게 생각만 한다고 되는게 아닙니다. 뭐든지 끝을 볼때까지 열심히 해야됩니다.</p>

<p>제가 동아리하면서 만족스럽게 공부를 못했다고 했지 열심히 안한건 아닙니다. 동아리 들어온지 3개월만에 부회장으로 임원활동을 하게 되었고 스터디 조직하고 세미나 맡아서 진행하고 시험기간에도 웹해킹, 리버싱 등을 공부했죠.</p>

<p>그건 현재 저를 아는 다른 동아리원들에게 물어보면 알수 있을 겁니다.</p>

<p>결국 안해보면 이게 나한테 맞는지 안맞는지, 똥인지 된장인지 모른다는 말이죠.</p>

<p>시간을 쪼개서 공부를 하신다고 했지만, 시간을 쪼갠다는 말이 잘못된 것 같네요. 본인 인생에 있어서 중요하고 가치있는 것만 해도 모자란데 지금 다른 일을 하면서 시간을 쪼개서 소프트웨어 개발 공부를 한다? 넌센스입니다.</p>

<p>안드로이드 프로그래밍, 리눅스 프로그래밍, 윈도우 프로그래밍, 어떤 특정 언어, 플랫폼, 마음만 먹으면 1주일이면 다 할수있습니다. 그게 여기 소프트웨어 마에스트로 수준입니다. 하지만 그건 실력이 아니라 마음가짐입니다.</p>

<p>안드로이드를 공부해야지가 아니라.. &lsquo;이러한 문제가 있는데 이렇게 풀어서 사람들에게 가치를 제공하고 싶은데 모바일이 제일 적합한것 같애. 그럼 일단 우리나라에서 제일 점유율이 높은 안드로이드 개발을 먼저 해보자.&rsquo;</p>

<p>그러면 언어든 플랫폼이든 그건 하나의 수단에 불과하게 됩니다. 중요한건 그 문제이고 그 문제를 풀어가는 과정인 것이죠. 그러면 C언어 잘할려면 어떻게 해야되나요? 안드로이드 배우는데 얼마 걸리나요? 같은 얘기는 더 이상 안하게 됩니다.</p>

<p>안드로이드 배울려면? 1년이 걸릴수도 10년이 걸릴수도 있습니다. 하지만 문제에 집중하면 하루면 충분할 수도 있습니다. 접근을 어떻게 하느냐에 따라서 그 시간은 천차만별일 겁니다.</p>

<p>그리고 전산 전공을 하시면 가장 기본적으로 코딩 실력이 중요합니다. 소프트웨어 마에스트로 면접 때도 코딩 문제 풉니다. 30분 시간 주어지고 실제 언어로 다 풀어서 면접때 설명할 수 있어야 합니다. 프로그래머가 코딩을 못한다는건 말이 안되는 거니깐요. (괜찮은 소프트웨어 기업은 기본적으로 이런 채용방식을 가지고 있습니다.)</p>

<p>정리를 하자면,</p>

<p>먼저 본인에 대해서 잘 생각해보세요. 정말 뭘 원하는지 그리고 그런게 여러 개 있으면 하나씩 다 해보세요. 정말 열심히. 아직 대학생이잖아요?</p>

<p>그리고 남은 기간 동안 본인 스스로 기획한 프로젝트를 최소한 2 개 이상 해보세요.저 처음 웹프로젝트 할때 서비스를 런칭했습니다. 개발만 끝낸게 아니라 디자인, 런칭, 운영까지.</p>

<p>마지막, 코딩 연습하세요. 리눅스? 윈도우? 안드로이드? 그런거 어차피 API 보고 가져다 쓰는 거 그 이상 그 이하가 될 수 없습니다. 책보고 공부하면 되죠. 코딩 실력? 이거 연습안하면 절대 안늡니다. 앱 엄청 예쁘게 짜놓고 조건문, 반복문 제대로 활용 못하는 프로그래머들 태반입니다. BOF, 웹해킹 백날 하면 뭐합니까. 학교 알고리즘 과제 하나 제대로 못짜는데.. 보안하든 뭘하든 코딩 잘해야됩니다. 지금 우리 동아리 현업에서 일하시는 선배들 보안 잘합니다. 코딩? 더 잘하시죠.</p>

<p>TopCoder, Project Euler 등 최소한 하루에 한 문제씩 푸는걸 목표로 하세요. 그러면 소프트웨어 마에스트로 면접은 쉽게 할 수 있습니다. 생각하는 연습, 그걸 코딩으로 옮기는 연습, 그걸 또다시 설명하는 연습. 매일 문제 풀기 어렵습니다. 스터디를 하든 자신의 강한 의지를 발휘하던 꼭 진행하세요.</p>

<p>2014년도 마이크로소프트 1월호, 2월호, 3월호 패턴 이야기 편을 보면 제가 소프트웨어 마에스트로에서 어떻게 기획하고 어떤 것들을 공부해서 개발하는지를 대략적으로나마 알 수 있을 것입니다. 참고하시구요.</p>

<p>말을 쓰다보니 잡다한 제 생각이 많이 들어갔네요. 추가적인 질문은 메일로 다시 보내주시구요. 만약에 진정 내가 이걸 하고 싶다면 망설이지 말고 그것에만 집중하세요. </small></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[14th JCO Conference 발표 후기]]></title>
    <link href="http://flowkater.github.io/blog/2014/03/04/review-jco-team-speech/"/>
    <updated>2014-03-04T21:45:00+09:00</updated>
    <id>http://flowkater.github.io/blog/2014/03/04/review-jco-team-speech</id>
    <content type="html"><![CDATA[<p><small>&nbsp;&nbsp;2014년이 시작되고도 3월이 되었습니다. 마지막 포스팅이 작년 10월쯤인가요. 거의 블로그를 버려두다가 이제 좀 더 자주 포스팅을 해야될 것 같습니다. 항상 좀 제대로 된 글을 써야된다는 부담감에 아예 글쓰기를 시도조차 안하는 것 같애서 그냥 제 글의 퀄리티보다는 좀 더 형식없이 자유롭게 글을 많이 쓰자로 가야될 것 같습니다.</p>

<p>&nbsp;&nbsp;일단 근황은 많은 일이 있었네요. 소프트웨어 마에스트로 4th 연수생 입장으로 프로젝트를 진행하면서 무사히 2단계 합격을 해서 프로젝트를 잘 진행하고 있고 2014년도 마이크로소프트웨어 잡지에도 기고(이건 다시 포스팅할게요.)하고 2월에는 우리나라에서 가장 큰 자바 개발자 행사인 JCO에서 발표를 하기도 했습니다. 그래서 오늘은 그 발표 후기에 대해 한번 써보자! 입니다.</small></p>

<p><img src="http://imageshack.com/a/img607/5356/5cld.png" alt="JCO Logo" /></p>

<!-- more -->


<p>&nbsp;&nbsp;<a href="http://www.jco.or.kr/">JCO</a>는 &ldquo;국내 자바 개발자들에게 최신 기술과 정보, 트렌드를 전달하고 함께 공유할 수 있는 장을 마련하는 단체이고, 외국 벤더와 외국 커뮤니티와의 교류를 통해서 국내 개발자들에게 최신 자바 소식을 전달해주는 역할을 수행하고 있는 단체입니다.&rdquo; 라고 소개가 되고 있는데 한마디로 국내 최대 자바 개발자 커뮤니티가 아닌가 합니다.</p>

<p>&nbsp;&nbsp;실제로 예전에는 JCO 컨퍼런스가 국내 개발자 행사에선 거의 유일한 큰 행사였는데 최근에 NHN에서 NHN Deview 행사, Daum 의 DevOn 등 국내 기업들의 개발자 컨퍼런스가 많이 생기고 있는 것 같습니다. 좋은 현상이죠 :)</p>

<p><img src="http://imageshack.com/a/img203/6185/xtws.png" alt="14th JCO conference" /></p>

<p>&nbsp;&nbsp;어쨋든 지난 2월 22일 <a href="http://www.jcoconference.co.kr/">제 14회 한국자바개발자 컨퍼런스</a>에서 소프트웨어 마에스트로 4th Cerberus팀 저와 팀원 두 명이 발표 무대에 서게 되었습니다. 아직도 긴장하면서 발표했던 순간, 발표 후 우리 프로젝트에 많은 공감을 보여주셨던 청중 분들을 생각하면 가슴이 두근두근 뛰네요.</p>

<p><img src="http://imageshack.com/a/img703/8967/v3ch.png" alt="Cerberus Team" /></p>

<p>&nbsp;&nbsp;그럼 도대체 저희 같은 학생들이 어떻게 저 행사에서 발표를 하게되었냐? 가 제일 궁금하실 건데요. JCO는 처음 컨퍼런스를 기획과 준비를 하면서 발표자 모집 공고를 내게 됩니다. 발표를 하고 싶은 사람은 구글 독스에다가 어떤 발표를 할건지 ppt 약식을 보내주면 되는 것이죠. 저희 팀은 현재 저희 멘토님이신 손영수 멘토님의 권유로 발표를 신청하게 되었습니다. 간단하죠? 그런데 여기서 발표 지원자들과 발표 주제를 대상으로 선호도 조사가 진행되게 됩니다. 선호도 조사는 국내 개발자 커뮤니티 여기저기서 홍보가 되죠.</p>

<p>&nbsp;&nbsp;저희 팀도 나쁘지 않은 선호도 조사 결과도 있었고 JCO 7대 회장님인 유현석 회장님께서 저희를 좋게 보셔서 발표자로 선정이 되었던 것 같습니다. 소프트웨어 마에스트로 간판이 좀 컸던 것 같네요 :)</p>

<p>&nbsp;&nbsp;그 후 로는 좀(?) 괴로웠습니다. 아무래도 큰 행사이다보니 저희끼리도 ppt 준비하는데 스트레스를 많이 받았던 것 같습니다. 그래도 손영수 멘토님께서 옆에서 적극적으로 도와주신 덕분에 무사히 끝마칠 수 있었죠. (멘토님과 같이 날밤을 샜더랬죠.. 흐흨) JCO 유현석 회장님께서도 발표 리허설 봐주시고 많은 피드백 주셨고 멘토님과도 리허설을 몇 번 진행하면서 준비 과정을 마쳤습니다.</p>

<p>&nbsp;&nbsp;발표자 권한으로 초청도 하고 발표때 보여줄 동영상도 편집하면서 만반의 준비를 끝마치고 특히 다른 발표자분들은 혼자서 발표를 진행하는데 저희 팀은 세 명이 돌아가면서 파트별로 나눠서 발표를 했기 때문에 실제로 개인 개인의 발표시간은 훨씬 부담이 적었지만 세 명의 호흡을 맞추는 것이 생각보다 쉽지 않은 일이었던 것 같습니다.</p>

<p><img src="http://imageshack.com/a/img855/4664/k1n3.png" alt="긴장.png" />
<img src="http://imageshack.com/a/img21/5013/z9qz.png" alt="저희 세션을 선택해주신 감사한 분들" /></p>

<p>&nbsp;&nbsp;발표 당일 저희 세션은 100명 정도 들어오는 컨퍼런스룸을 할당받았는데 거의 120명 이상의 분들이 저희 발표를 찾아오셨습니다. 발표 시작 전에 왠지 학생분들 보다는 실무 개발자 분들이 훨씬 많아 보여서 긴장했지만 어차피 저희의 삽질기(?)를 보여준다고 생각하고 마음 편히 발표를 진행했었습니다. 청중분들의 집중도도 꽤 높았고 발표 직후 쏟아지는 질문과 공감, 받은 명함들을 보면서 발표가 잘끝났구나, 궁극적으로는 우리가 진행하는 프로젝트가 많은 사람들의 공감을 얻어내고 있구나를 느꼈습니다.</p>

<p><img src="http://imageshack.com/a/img541/2481/g796.jpg" alt="발표자 1" />
<img src="http://imageshack.com/a/img703/2744/72db.jpg" alt="발표자 2" />
<img src="http://imageshack.com/a/img513/9923/fc4m.jpg" alt="발표자 3" /></p>

<p>&nbsp;&nbsp;결과적으로 하기 전에는 굉장히 많이 부담되고 준비하는 과정에서도 분명 힘든 점이 있었으나 확실히 큰 컨퍼런스에서 저희의 기술을 공유하고 발표하고 공감을 나누는 경험은 정말 값진 경험이었던 것 같습니다.</p>

<p><img src="http://imageshack.com/a/img46/8002/e7qa.jpg" alt="발표 후" /></p>

<p>&nbsp;&nbsp;저희 팀이 각각 적은 셀프 피드백도 <a href="https://docs.google.com/spreadsheet/ccc?key=0AqDqphPwAZV0dHhVTGJGZFJWT1haWVRMTU1XdzFqWUE#gid=0">여기서</a> 보실 수 있습니다.</p>

<p>&nbsp;&nbsp;밑에는 저희가 발표한 자료를 공유하겠습니다. JCO 후기를 시작으로 포스팅을 다시 시작하려고 하는데 잘 전달이 됬는지는 모르겠습니다. 읽어주셔서 감사합니다.</p>

<p>&nbsp;
&nbsp;</p>

<script async class="speakerdeck-embed" data-id="dab41c107f4c01311bfb5ee28cb54637" data-ratio="1.41436464088398" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 앱 성능 최적화 발표 자료]]></title>
    <link href="http://flowkater.github.io/blog/2013/10/02/android-app-performance-optimization/"/>
    <updated>2013-10-02T20:42:00+09:00</updated>
    <id>http://flowkater.github.io/blog/2013/10/02/android-app-performance-optimization</id>
    <content type="html"><![CDATA[<p><img src="http://img202.imageshack.us/img202/7571/nxhl.jpg" alt="AndroidSpeed" /></p>

<p>Software Maestro 4th RiojaVega 팀에서 가볍게 스터디한 발표 자료를 공유하고 추후 자료를 더 보강해서 계속해서 업데이트 하겠습니다. <!--more --></p>

<p>&nbsp;
<a href="http://book.naver.com/bookdb/book_detail.nhn?bid=6884738">안드로이드 앱 성능 최적화</a> 책을 기반으로 스터디를 진행하였습니다. 전부 다 한 건 아니고 필요한 부분만 뽑아서  진행하였습니다. 또한 책에 자세한 내용이 없는 Java Reference(SoftReference, WeakReference, PhantomReference, GC관련) 부분을 추가 스터디하고 발표하였습니다.</p>

<h2>자바코드 최적화 &ndash; 발표자 노성현님</h2>

<script async class="speakerdeck-embed" data-id="f1ed19e00d8401310cb45a5691a014fc" data-ratio="1.41436464088398" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>효율적인 메모리 사용 &ndash; 발표자 조재우(flowkater)</h2>

<script async class="speakerdeck-embed" data-id="4117aaf007bd0131eb4f466920ceb80d" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>Java Reference &ndash; 발표자 조재우(flowkater)</h2>

<script async class="speakerdeck-embed" data-id="cac7dd1007bc01314749721d7d8450d6" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>멀티스레딩과 동기화 &ndash; 발표자 노성현님</h2>

<script async class="speakerdeck-embed" data-id="562876000bc80131e1fa0ef180755b8e" data-ratio="1.41436464088398" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>벤치마크와 프로파일링 &ndash; 발표자 박종훈님</h2>

<script async class="speakerdeck-embed" data-id="33c129b00bc90131c75e7eb2be81de58" data-ratio="1.41436464088398" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>배터리 최대한 사용하기(전원 측정) &ndash; 발표자 박종훈님</h2>

<script async class="speakerdeck-embed" data-id="042e53f00d8501311ad76e6096b64521" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>그래픽(레이아웃) &ndash; 발표자 조재우(flowkater)</h2>

<script async class="speakerdeck-embed" data-id="22dbb7300d8501312b96265f492ef2cd" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[페르마의 마지막 정리를 읽고]]></title>
    <link href="http://flowkater.github.io/blog/2013/08/27/fermats-last-theorem/"/>
    <updated>2013-08-27T14:54:00+09:00</updated>
    <id>http://flowkater.github.io/blog/2013/08/27/fermats-last-theorem</id>
    <content type="html"><![CDATA[<p><img src="http://bookthumb.phinf.naver.net/cover/001/205/00120540.jpg" alt="페르마의 마지막 정리" /></p>

<p><strong>“Cuius rei demonstrationem mirabilem sane detexi hanc marginis exiguitas non caperet.
나는 경이적인 방법으로 이 정리를 증명했다. 그러나 책의 여백이 너무 좁아 여기에 옮기지는 않겠다.”</strong><br/>
&nbsp;
페르마의 마지막 정리란,  <!-- more --></p>

<pre><code>"x^n+y^n=z^n; n이 3이상의 정수일 때, 이 방정식을 만족하는 정수해 x, y, z는 존재하지 않는다."
</code></pre>

<p>이다.<br/>
&nbsp;그러나 페르마는 이 정리를 자신의 [아리스메티카]에 코멘트하면서 &ldquo;나는 경이적인 방법으로 이 정리를 증명했다. 그러나 책의 여백이 너무 좁아 여기에 옮기지는 않겠다.&rdquo; 라는 발칙한(?) 말을 남겨놓았다.<br/>
&nbsp;이 정리를 증명하기 위해 수많은 사람들이 도전하였으나 300여년이 넘는 세월동안 그 누구도 증명하지 못하는 난제가 되었다.<br/>
&nbsp;사실 &lsquo;피에르 드 페르마&#8217;는 정식 수학자가 아닌 아마추어 수학자로서 실제로 법조인 일을 하면서 취미로 수학을 했다고 한다. 그래서 페르마의 마지막 정리만 보고 그냥 단순히 페르마가 장난을 쳤다고 할 수도 있겠지만 실제로 그는 천재적인 수학 재능으로 여러 정리와 증명을 만들어냈다고 한다. 하지만 공유 정신이 없었던(오픈소스 정신이 없었던..) 그는 대충 자신이 증명했다고 생각하면 그냥 휘갈기고 넘어가는게 대부분이었다고 한다. 법조인으로써 잘 살고 있던 그에게 수학자로서 후학양성이나 지식공유는 아웃오브안중이었을거고.. 실제로 [아리스메티카]는 페르마의 아들에 의해서 완성된 책으로 페르마의 아들도 여기에 관심이 없었다면 페르마의 마지막 정리도 다른 이름이 되었거나 위의 정리가 그렇게까지 사람들에게 관심을 받지 못했을 수도 있다.<br/>
&nbsp;어쨋든 이러저러해서 페르마의 마지막 정리가 탄생되어 수많은 사람들이 도전했고 자살, 정신이상, 결투 등의 좋지 않은 사이드 이펙트를 일으키며 300여년이 지나면서 풀리지 않는 문제로 남아있게 되었다.<br/>
&nbsp;책에서는 페르마의 이야기부터 정리가 나오게 된 배경(피타고라스의 정리부터..) 여러가지 정수론 이야기, 페르마의 마지막 정리가 증명되기까지 영향을 준 수많은 수학자, 이론 등을 설명하면서 숨가쁘게 진행되다가 드디어 이 책의 주인공인 &#8216;앤드루 와일스&#8217;에 의해 증명이 되는 그 순간을 극적으로 묘사한다.<br/>
&nbsp;수학적인 흥미를 일으키기 충분한 소재들이었고 정수론이나 현대대수학을 공부해보고 다시 한번 이 책을 읽으면 더 재밌지 않을까하는 생각이 든다.<br/>
&nbsp;재밌는 수학자의 이야기도 많아서 그들의 인간적인 삶과 수학 그 자체에 대해서도 이해하게 된 것 같다. &#8216;Numb3rs&rsquo; 미드를 보면 주인공인 찰리가 사건 해결에 수학을 응용하면서 나는 &lsquo;아 수학을 알면 이렇게 실생활에 응용할 수 있구나.&rsquo; 라고 생각을 했는데 &lsquo;박사가 사랑한 수식&#8217;이라는 영화를 보면 주인공인 박사가 정확히는 기억이 안나지만 이런 얘기를 한 것 같은데.. &#8216;수학은 수학 그 자체로 아름다운 것이다.&rsquo; 즉, 어디에 활용되고 응용되는 것이 아니라 그 수의 세계와 법칙, 논리적인 증명 등 수학 그 자체가 아름답다는 말을 해주고 있었다.<br/>
&nbsp;사실 우애수, 완전수 등의 얘기를 하면서 그런가보다 했는데 페르마의 마지막 정리를 읽으면서 그러한 아름다움에 대해서 미약하게나마 느낄 수 있는 계기가 된 것 같다.<br/>
&nbsp;이 책을 읽으면서 수학에 대한 여러 생각을 가지게 된 것도 있었지만 더 감명깊었던 건 이 페르마의 마지막 정리를 증명하는 &lsquo;앤드루 와일즈&#8217;의 삶이었다. 그는 7년하고도 1년(첫 발표후 오류가 발견되어 1년의 시간을 오류해결을 위해 보낸다)동안 페르마의 마지막 정리 하나만을 풀기 위해 보낸다.(정확히 얘기하자면 타니야마-시무라의 추측부터 여러 수학 정리들을 함께 풀어나가면서 해결했다.) 아무하고도 교류없이 7년간의 은둔 생활을 하면서 증명을 하고 발견된 오류를 해결하기 위해 엄청난 스트레스에 시달리면서 1년을 다시 은둔 생활을 하면서 마지막까지 문제 해결의 끈을 놓지 않은 그의 모습을 보면서 여러가지를 느낄 수 있었다.<br/>
&nbsp;그건 정말 가치있는 삶을 살아가는 자세이기도 했다. 나의 개인적인 경험만을 들여다보아도 정말 오랜시간 단 하나에 집중했을때 거기서 정말 가치있는 결과들이 나왔었다. 요즈음 너무 이것저것 일을 벌이면서 마무리를 못하고 있는 내 모습을 보면서 다시 한번 내가 집중해야되는 것은 무엇인가에 대해서 생각하게 되는 계기가 된 것 같다.<br/>
&nbsp;나는 수학을 잘 못한다. 그런데 컴퓨터 공학을 하면서 순수 과학에 대한 욕심이 생겨나서 계속 공부를 하려고 했지만 학창시절 스스로 만든 장벽 때문에 도전하지 못하고 있었다. 정수론과 현대대수학 쪽 커리큘럼이 보니 이 책에서 나왔던 수학자들의 이름이 모두 보인다. 그들의 삶을 조금이나마 알고나니 뭔가 이것들이 친숙해보이는 느낌이 든다. 나도 페르마처럼 아마추어 수학자가 되어보자. 그처럼 천재적인 재능은 없지만 수학 그 자체의 아름다움을 만끽하면서 취미 생활을 영위해나가는 것도 나쁘지 않을 것 같다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[루비 온 레일스 아키텍처 디자인]]></title>
    <link href="http://flowkater.github.io/blog/2013/08/12/rails-architecture/"/>
    <updated>2013-08-12T20:33:00+09:00</updated>
    <id>http://flowkater.github.io/blog/2013/08/12/rails-architecture</id>
    <content type="html"><![CDATA[<p><em><small>영어와 한국어에(..) 익숙치 않아 오역이 많습니다. 감안하고 읽어주시면 감사하겠습니다. 지적 또한 감사히 받겠습니다. 2011년 글인데 번역 연습도 할겸 건드려보았습니다. 당시 레일스 아키텍처 이야기라서 지금이랑 조금 다를 수 있습니다.</small></em></p>

<h1>1. 소개</h1>

<p>루비 온 레일스(RoR)는 Ruby 프로그래밍 언어로 작성한 오픈 소스 웹프레임워크이다. 레일스의 모든 애플리케이션은 Ruby로 작성한다. 루비 온 레일스는 생산성과 애자일(agile) 웹 개발 적용에 중점을 두고 있다.</p>

<p>레일스 프레임워크는 Ruby 언어의 특성을 활용한다. 유키히로 마츠모토(Yukishiro Matzumoto)는 1995년, Perl, Eiffel, Python, Smaltalk 와 그 외 다른 언어에 영향을 받아 이 언어를 디자인했다. 동적 타입, 완전한 객체 지향, 범용성을 가진 스크립트 언어 등이 그 특징이다. Ruby는 우아한 문법과 가능하면 사람이 읽기 쉽게 디자인되었는데 예를 들어 콜론(;)이 없어도 되고 메서드 인자에 괄호가 필요없다. 코드 일부는 영어 문장처럼 쉽게 읽을 수 있다. <!-- more --></p>

<p>루비 온 레일스 프레임워크는 데이터베이스 기반의 웹 애플리케이션을 위해 디자인되었다. 루비 온 레일스는 J2EE나 .NET 같은 무거운 웹 프레임워크에 대응하기 위해 만들어졌다. 개발 프로세스를 더 빠르게 만들기 위해서 루비 온 레일스는 관례(Convention)를 사용한다. 그리고 작업을 완료하기 위해서 최상의 방법으로 고려되는 가정들(여기서 이렇다면 저기서는 이럴 거 같다는 가정들)을 사용하고 이러한 관례와 가정의 사용을 장려하도록 디자인되었다. 이 관례는 설정 코드를 제거하고 생산성을 높인다. 웹 개발의 대부분의 공통된 작업들은 바로 바로 작업할 수 있도록 프레임워크에 내장되어 있다. 이메일 관리, 객체 데이터베이스 매퍼, 파일 구조, 코드 제네레이션, 구성 요소들의 네이밍과 조직하는 방법뿐만 아니라 다양한 기능들을 내장하고 있다. 이 모든 관례는  개발자에게 더 적은 코드를 쓰게 하고 애자일(agile) 애플리케이션 개발을 하도록 도와준다. 또한, 루비 온 레일스 개발자 커뮤니티에서 개발 코드에 대한 유지 보수성 및 이해도를 향상할 수 있는 팁들을 얻을 수 있다.</p>

<p>Ruby온 레일스 아키텍쳐가 가지는 특성들:</p>

<ul>
<li> 모델(Model)-뷰(View)-컨트롤러(Controller) 아키텍쳐</li>
<li> REST(Representational State Transfer) 웹서비스</li>
<li> 주요 데이터베이스 지원 (MySQL, Oracle, MS SQL, PostgreSQL, IMB DB2, and more).</li>
<li> 오픈 소스 서버 사이드 스크립트 언어</li>
<li> 설정보다는 관례</li>
<li> 업무를 자동화하는 스크립트 생성자(generator)</li>
<li> 사람이 읽기 쉬운 직렬화 데이터 포맷인 YAML 사용</li>
</ul>


<p>위 묘사된 특성들은 아래 레일스 구성요소들로 배포된다. Fig. 2 그림에서 이러한 구성요소들 사이의 상호작용을 보여준다:</p>

<ul>
<li> Action Mailer</li>
<li> Action Pack

<ul>
<li>Action Controller</li>
<li>Action Dispatcher</li>
<li>Action View</li>
</ul>
</li>
<li> Active Model</li>
<li> Active Record</li>
<li> Active Resource</li>
<li> Active Support</li>
<li> Railties</li>
</ul>


<p><img src="http://imageshack.us/a/img844/1016/v2k.png" alt="Figure 2. Reference model depicting the overall framework architecture" /></p>

<h2>1.1  모델(Model)-뷰(View)-컨트롤러(Controller) 패턴</h2>

<p>루비 온 레일스는 애플리케이션의 유지보수를 개선하기 위해서 모델(Model)-뷰(View)-컨트롤러(Controller) (MVC) 아키텍쳐 패턴을 사용한다. 모델은 비지니스 로직에 집중하고 뷰는 디스플레이 로직을 관리, 컨트롤러는 애플리케이션의 흐름을 다룬다. MVC 는 HTML뷰로부터 분리된 비지니스 로직을 유지하는 방법으로 문제(관심사)를 깔끔하게 분리해준다. 게다가, MVC는 디커플링(분리)과 테스팅을 개선해준다.</p>

<h3>1.1.1        모델(Model)</h3>

<p>모델 계층은 애플리케이션의 비지니스 로직과 데이터를 조작할 수 있는 규칙들을 수행한다. 루비 온 레일스에서 모델은 데이터베이스 요소들과의 상호작용을 관리하는데 사용된다. 모델은 데이터베이스 내의 정보를 나타내고 적절한 검증을 한다.</p>

<h3>1.1.2        뷰(View)</h3>

<p>뷰는 애플리케이션의 프론트 엔드로 사용자 인터페이스를 나타낸다. 루비 온 레일스에서 뷰는 Ruby 코드가 삽입된 HTML 파일들이다. HTML 내 삽입된 Ruby 코드는 꽤 단순하다(반복문, 조건문). 이 코드들은 뷰의 폼 내에서 사용자에게 데이터를 보여주기 위해서만 사용한다. 웹 페이지를 요청한 브라우저에 데이터를 제공할 때 뷰를 사용한다. 뷰는 HTML, PDF, XML, RSS 같은 몇 가지 형식으로 컨텐츠를 제공할 수 있다.</p>

<h3>1.1.3        컨트롤러(Controller)</h3>

<p>컨트롤러는 모델과 뷰의 상호작용이다. 브라우저로 부터 들어온 요청은 컨트롤러에 의해 처리되는데 모델로 부터 데이터를 처리하고 그것을 표현하기 위해 뷰에게 전달해주는 역할을 한다.</p>

<h2>1.2       레일스 모듈(Rails Modules)</h2>

<h3>1.2.1        Action Mailer</h3>

<p>이 모듈은 e-mail 서비스 제공을 담당한다. 이 모듈은 들어오는 메일을 처리하고 새로운 메일을 만든다. 이 모듈은 간단한 텍스트나 복잡한 포맷의 이메일들을 다룰 수 있다. 또한, 이 모듈은 공통적인 작업들을 내장하고 있는데, 잊어버린 암호를 보내는 경우, 환영 메시지, 그리고 다른 종류의 텍스트 기반 메시지 기능을 제공한다. Action Mailer는 Action Controller를 래핑한다. 그래서 Action View에서 웹 페이지를 렌더링하기 위해 사용하는 방법과 같은 방법으로 템플릿을 이용해 email 메시지를 만드는 방법을 제공한다.</p>

<h3>1.2.2        Action Pack</h3>

<p>Action Pack 모듈은 MVC 패턴의 컨트롤러와 뷰 계층을 제공한다. 이 모듈들은 브라우저에 의한 사용자의 요청을 받아서 이 요청들을 액션에 매핑한다. 이러한 액션들은 컨트롤러 계층에서 정의되어 지고 액션들은 브라우저에 디스플레이되어지는 뷰를 렌더링한다. Action Pack은 세 개의 서브 모듈로 나누어져 있는데, Action Dispatch, Action Controller, Action View이다.</p>

<ul>
<li><p> Action Dispatch: 웹 브라우저 요청의 라우팅을 다룬다. 웹 요청을 파싱하고 쿠키 핸들링, 세션, 요청 메서드 등의 HTTP 에 관한 고급 처리를 수행한다.</p></li>
<li><p> Action Controller: 이 모듈은 Action Dispatch가 요청을 처리하고 난 후에 해당 컨트롤러에 라우팅한다. 이 모듈은 모든 다른 컨트롤러들이 상속받을 수 있는 기본 컨트롤러를 제공한다. Action Controller는 모델과 뷰를 제어하기 위한 액션들을 포함한다. 이 모듈은 필요에 따라 사용할 수 있는 데이터를 만들고 뷰의 렌더링과 리다이렉션을 제어한다. 게다가 사용자 세션, 애플리케이션 흐름, 캐싱 기능, 헬퍼 모듈과 사전 필터 구현, during과 post processing hooks를 관리한다.</p></li>
<li><p> Action View: 이것은 Action Controller에 의해 호출된다. 요청된 웹페이지의 표현을 렌더링한다. Action View 는 마스터 레이아웃, 템플릿 룩업과 HTML 생성을 도와주는 헬퍼, 피드, 다른 표현 포맷을 제공한다. 레일스에는 세가지 템플릿 스키마가 있는데 rhtml, rxml, rjs 이다. rhtml 포맷은 ERB(Ruby 코드가 삽입된 HTML)를 사용자에게 HTML뷰로 생성해준다. rxml 은 Ruby를 사용한 XML 문서들을 구성하기 위해 사용되고 rjs 는 AJAX기능을 구현하기 위해 Ruby 코드내에서 동적 자바스크립트 코드를 만드는 것을 허락해준다.</p></li>
</ul>


<h3>1.2.3        Active Model</h3>

<p>Action Pack과 Active Record 모듈 사이의 인터페이스로 정의된다.</p>

<h3>1.2.4        Active Record</h3>

<p>Active Record는 관계 데이터베이스의 데이터를 객체를 통해 관리하기 위해 사용되는 아키텍처 패턴이다. 루비 온 레일스에서 Active Record 모듈은 클래스로 객체 관계 매핑(ORM)을 제공한다. 이 모듈은 데이터베이스 테이블에 연결하는 모델 계층을 Ruby 클래스 표현으로 만든다. 레일스는 설정없이 CRUD 기능을 구현하기 위한 도구들을 제공한다. CRUD는 데이터베이스 내의 레코드를 만들고(create), 읽고(read), 수정하고(update), 지우는(delete) 액션을 Ruby 객체를 통해서 하도록 해준다. 한 객체 표현은 데이터 베이스 각 행(row)을 표현한다. Active Record 는 어떻게 클래스가 네이밍되고 테이블이되고 foreign key 와 primary key가 어떻게 되어야 하는지를 관례에 크게 의존한다.(역자: 즉, 관례로 사용되는 일정한 법칙을 가지고 있다.) 데이터베이스 매핑이 설정을 사용하여 사용될 수 있지만 그러한 액티브 레코드 모듈들이 Rails 관례를 따르는 것을 매우 권장한다.</p>

<p>이 모듈들은 비지니스 로직(모델간의 관계, 검증)에 포함되는 모델 클래스를 생성하고, 자동으로 테이블과 캡슐화된 데이터에 매핑되고, 게터와 세터, 콜백을 제공하고, 또한 여러 데이터베이스를 지원하는데 사용된다.</p>

<h3>1.2.5        Active Resource</h3>

<p>Active Resource 모듈은 RESTful 웹서비스와 비지니스 객체들 사이에 연결을 관리하기 위해 사용된다. 코드의 양을 줄이기 위해 리소스를 매핑하는 Active Record와 같은 원리를 따른다. Active Resource 는 Active Record 가 모델 클래스를 데이터베이스 테이블에 매핑하는 것과 같은 방법으로 모델 클래스들을 원격 REST 리소스에 매핑한다. Active Resource는 HTTP 프로토콜을 강화하고(leverage) 복잡한 구조와 관계를 추측하기 쉽게 만들기 위한 코드 관례를 더해준다. Active Record 는 또한 Active Resource(client)와 RESTful 서비스 사이에서 프록시 기능을 제공하는데 이것은 REST 웹 서비스를 위한 객체 관계 매핑이 구현되면서 이루어진다.  원격 리소스에 대한 요청을 하면,  REST XML 이 생성되고 전송되어 Ruby 객체로 파싱된다.</p>

<h3>1.2.6        RESTful Architecture</h3>

<p>REST는 Representational State Transfer의 약자이다. REST 는 SOAP, WSDL 같은 웹서비스의 대안이다. 모든 CRUD(create, read, update, delete) 동작들이 HTTP 프로토콜에 의존한다. RESTful 웹 서비스는 웹서비스가 완전 무상태(stateless)일때, 제한된 대역폭일때(CRUD 는 SOAP 와 같은 다른 프로토콜에서의 오버헤드가 없기 때문에 모바일 장치에 매우 유용), 데이터가 동적으로 생성되지 않아서 성능 개선을 위해 캐싱을 해야되거나 서비스 생산자와 소비자 상호간의 이해가 있을때 적절하다.</p>

<h3>1.2.7        Active Support</h3>

<p>유틸리티 클래스의 모음과 루비 온 레일스 개발을 위해 유용한 Ruby 라이브러리의 확장이다. 멀티바이트 문자열, 국제화, 타임 존과 테스팅 등의 풍부한 지원을 포함한다.</p>

<h3>1.2.8        Railties</h3>

<p>Railties 는 새로운 애플리케이션을 만드는 Rails 핵심 코드이다. 위에서 설명한 모듈들이 모두 함께 잘 조합될 수 있게 하는(&ldquo;glue&rdquo;-ing) 역할을 한다. 또한, 모든 부트스트래핑 프로세스, 커맨드 라인 인터페이스를 처리하고 Rails 코드 생성기를 제공한다. Rake 는 데이터베이스 작업, 배포, 문서화, 테스팅, 클린업 등을 수행하기 위해 사용되는 커맨드 라인 도구 중 하나이다. Rails는 또한 유닛 테스팅, 뷰와 컨트롤러의 기능 테스트, YAML 을 사용한 테스트 데이터 지원이 되는 내장 테스팅 프레임워크를 제공한다. (코드가 생성될 때 자동으로 test 스텁(코드) 또한 같이 만들어 진다.)</p>

<h1>2. Architectural Solution</h1>

<p>이 아키텍처를 분석하기 위해 Module View와 Component and Connector(C&amp;C) View방식을 활용 하였다. Module View 는 모든 컴포넌트의 정적 뷰를 표현하는 UML 다이어그램을 포함할 것이다. 반면에 Component and Connector(C&amp;C) View는 시스템 아키텍처의 런타임 뷰를 표현하는 UML 다이어그램을 보여줄 것이다.(어떤 컴포넌트가 런타임에 존재하고 어떻게 각 컴포넌트가 커뮤니케이션하는지)</p>

<h2>2.1       Connect and Component View</h2>

<p>C&amp;C View는 컴포넌트, 인터페이스, 커넥터와 시스템을 표현하는 전체 시스템의 동적인 뷰이다. 인터페이스는 UML 인터페이스 표기법으로 표현하였다. 이것은 인터페이스를 간결하게 표현하여 다이어그램이 복잡해지는 것을 피한다. 인터페이스 표현에서 사용되는 UML 표기법과 일치하도록 링크로 커넥터 인스턴스와 관계를 나타낼 것이다. 같은 방법으로 시스템은 UML 서비스 시스템들로 나타내고 있다.</p>

<p><img src="http://imageshack.us/a/img407/9381/rh4k.jpg" alt="Figure 3.  Dynamic View: Ruby on Rails Connector and Component View" /></p>

<h2>2.2       Modules View</h2>

<p>Module 뷰는 모듈로써 코드 구현과 인터페이스 표현으로 그들 사이의 관계를 보여준다. Module 뷰는 모듈, 인터페이스, 집합(집합관계), 일반화와 의존성을 포함한다. 이 뷰들은 아키텍처의 정적 뷰를 표현하기 위한 적절한 방법이다.</p>

<p><img src="http://imageshack.us/a/img600/3431/zm78.jpg" alt="Figure 4. Static View: Ruby on Rails Module View" /></p>

<h1>3. 루비 온 레일스 아키텍처의 위험들</h1>

<p>Rails는 Ruby 언어로 만들어졌기 때문에 언어의 장단점을 그대로 가지고 있다. Ruby는 우아한 문법과 완전한 객체 지향을 지원하는 동적인 스크립트 언어이다. 인터프리터 언어이기 때문에 컴파일 언어인 Java, C++ 보다 느리다. 대부분의 경우에 속도에서의 차이점은 문제가 되지 않는다. 그러나 웹 애플리케이션이 수백만의 동시접속자들을 처리하기 위해 규모를 늘리려고 하면 (scale) 프레임워크 퍼포먼스가 낮아지기 시작한다. Ruby 언어는 컴퓨팅 환경(빠른 연산, 스레드 처리)에 최적화되지 않았기 때문에 높은 동시 처리에 맞지 않는 언어이다. Ruby는 문법이 우아하고 간단하며 빠르게 개발하기 위해 디자인되었다. Ruby는 아직 스레드 지원이 좋지 않고, 많은 다른 스크립트 언어처럼  long-lived 프로세스들을 다루는 데 문제가 있다. 그러나 Java 같은 다른 언어들은 스레드를 효율적으로 처리하기 위해 몇 년간 최적화되어있다. 또 다른 약점은 Ruby의 가비지 콜렉터는 자바의 그것보다 좋지 않아 각 프로세스는 더 많은 메모리를 요구한다. 배포의 관점에서 루비 온 레일스 웹어플이케이션은 PHP 같은 더 일반적인 기술을 사용하는 사이트들보다 배포하기 더 힘들 수도있다.  모든 호스팅 서버들이 Rails를 지원하는 게 아니기 때문이다. 그러나 요즘에는 Rails에 대한 지원이 점점 증가하고 있다.</p>

<p>다음의 특성을 가지는 애플리케이션에는 루비 온 레일스는 맞지 않다:</p>

<ul>
<li> 단순한 정적 웹사이트 (레일스 프레임워크를 사용하는 것이 오버헤드가 될 수 있다)</li>
<li> 컨텐츠 관리 시스템</li>
<li> 많은 양의 기존 코드나 레거시 코드에 의존하는 사이트</li>
<li> 레거시 데이터베이스 사이트</li>
<li> 멀티 사이트 서버, 단일 서버에 존재하는 수십 수백 개의 웹사이트가 필요한 상황</li>
<li> 고성능을 필요로 하는 매우 큰 웹 애플리케이션(동시접속사용자 수백만명)</li>
</ul>


<p>Rails 아키텍처는 best practice를 고려한 관례(convention) 기반의 생산성 증가를 위해 설정의 유연함을 희생했다. 이것은 다른 언어에 경험 있는 개발자가 &ldquo;Rails만의 길&#8221;에 얽매이도록 느끼게 만들 수 있다. 한편으론, Ruby는 우아한 문법, 생산성, 유지 보수성 때문에 속도와 리소스 관리 부분을 희생했다. 그러나 대부분 중소 엔터프라이즈 웹 애플리케이션은 상대적으로 작은 연산을 하고 지연(latency) 같은 요인, 대역폭(bandwidth), 데이터베이스 성능이 크게 중요하지 않다. 이러한 요인들은 수백만 동시 접속자를 처리해야 하는 높은 트래픽의 웹사이트에서 문제가 발생할 때 중요해진다.</p>

<h2>3.1       Twitter case study</h2>

<p>Rails를 사용한 high-트래픽 웹 애플리케이션 중 하나는 Twitter 이다. Twitter는 루비 온 레일스를 사용하여 시작하였으나 그들의 플랫폼을 확장하는데 비용 대비 효과가 없다는 것을 깨달았다. 이것은 주로 루비 온 레일스의 저조한 멀티 스레드 지원 때문이었다. 2011년에 그들은 주당 10억 개 이상의 트윗과 2억 명의 사용자를 갖게 되었다. 2011년에 그들은 Back-end application을 루비 온 레일스에서 Java로 이동하고 3배 더 빠른 검색과 더 좋은 높은 동시접속 수를 처리할 수 있다고 발표하였다.</p>

<p>Twiter 엔지니어링팀은 [1] 과 [2]에 따르면: &ldquo;우리는 노력의 일부분으로서 새로운 real-time 검색 엔진(우리의 백엔드를 MySQL 에서 Lucene의 real-time 버전으로 바꿨다.)을 런칭했다. 지난주, 우리는 우리의 루비 온 레일스 프론트엔드를 위한 교체작업을 했다: Blender라 불리는 Java server로 교체작업을 했는데 우리는 검색 지연을 3배 감소시켰고 몇 달 안에 빠르게 우리는 반복할 수 있다.&rdquo; 그리고 &ldquo;2011년 4월에, 검색 하부 구조에서 루비 온 레일스를 제거하고 검색 지연을 3배 개선하고 처리량을 10배 개선한 Blender라 불리는 Java 서버로 교체했다. 오늘, 우리는 18000QPS(매일 1.6B 쿼리) 서브하고 2200TPS 평균을 인덱싱한다. 더 중요한 건, Blender는 Summize 인수 이후 트위터 검색에서 가장 중요한 사용자 지향 변화(user-facing change)를 만드는  필요한 인프라 구축을 완료했다.&rdquo;</p>

<h2>3.2       Yellopages.com case study</h2>

<p>반면에 Yellopages.com은 Java에서 루비 온 레일스 프레임워크로 이동한 경우이다. 그들이 이러한 변화를 결정한 이유는 유지 보수성 증가, 완전한 URLs의 제어, 세션없이, 좀 더 애자일하게 간다는 주장이다. 그들은 한달 170백만 페이지 뷰와 하루 2.5백만 검색 쿼리를 가진다.</p>

<p>Brian Burridge는 Yellopages.com의 경우를 다음과 같이 설명한다. &ldquo;YelloPages.com은 Java에서 Rails로 이동했다. 그들은 한 달 2천3백만 방문자를 서브한다. 125,000 라인의 자바 코드 대신에 20,000 라인의 Ruby 코드로 전환은 그들이 좀 더 유지보수를 쉽게 할수있도록한다. 최적화된 그들의 사이트는 지금 이전보다 더 빠르다. 4명의 개발자가 3달만에 코드 재작성을 완료했다.&rdquo;</p>

<h1>4.       요약</h1>

<p>루비 온 레일스는 소프트웨어 개발 산업, 오픈 소스 커뮤니티에서 구체적으로 광범위한 지지를 받고 있다. 이러한 지지는 프레임워크가 아키텍트의 계획한 목표와 일관된 아키텍처를 제공할 수 있다는 점을 반영하고 있다.</p>

<p>루비 온 레일스 프레임워크는 프레임워크가 의도한 특성을 성공적으로 보여준다. 이러한 품질 유지의 책임은 서드 파티 컴포넌트에 의해서 결정이 된다. 그리고 성능의 경우에는 개발이나 배포 시간으로 설정되는 웹 서버에 의해 결정이 된다. 이 프레임워크의 가장 큰 강점은 &ldquo;설정 보다는 관례&rdquo;(Convention over Configuration)와 &ldquo;DRY&rdquo;(Don&rsquo;t Repeat Yourself) 원리이다. 이 원리는 품질 특성의 일부를 성취하기 위해서 특정 전략을 다룰때 직관적인 접근을 하게 해준다. 예를 들어 수정성(modifiability)은 (프레임워크가 특정 기능이 기본적인 위치에 배치되기 때문에) 특정 변화의 분리나 집중화로 적은 노력으로 수정 할 수 있다.</p>

<p>반면에, Rails는 Ruby언어의 약점을 그대로 가지고 있다. 특히 저조한 동시성 지원은 루비 온 레일스를 사용하여 만들어진 애플리케이션의 잠재적인 확장성을 저해한다. 또한, 메모리 관리가 다른 랭귀지가 사용하는 것처럼 효율적이지 못한다. 예를 들어 Java는 루비 온 레일스에 비교하여 더 좋은 가비지 콜렉터를 보여준다.</p>

<p>종합적으로,루비 온 레일스 프레임워크 아키텍처가 몇 가지 주의사항을 빼면 의도한 목표의 대부분을 충족한다고 볼 수 있다. 산업과 오픈 소스 커뮤니티 내에서 프레임워크 채택의 정도와 속도는 프레임워크가 가진 가능성에 대한 검증으로 사용될 수 있다. 동시에 우리는 루비 온 레일스 프레임워크의 한계를 보았다. 이러한 한계들은 루비 온 레일스를 지속적해서 발전하게 하는 원동력의 일부가 된다.</p>

<p><em><a href="http://adrianmejia.com/blog/2011/08/11/ruby-on-rails-architectural-design/">원본글</a> 해당 글을 번역하였습니다. 가볍게나마 바쁜 와중에 허접한 번역글을 점검해주신 창원이형에게 감사의 메시지를 전하고 싶습니다.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 와 Rails 배우고 싶을때]]></title>
    <link href="http://flowkater.github.io/blog/2013/08/07/ruby-and-rails-learning-resource/"/>
    <updated>2013-08-07T17:33:00+09:00</updated>
    <id>http://flowkater.github.io/blog/2013/08/07/ruby-and-rails-learning-resource</id>
    <content type="html"><![CDATA[<p>자칭, 타칭 만년 루비 꼴찌이지만 루비를 사랑하는 사람으로써 좀 더 많은 분들이 루비라는 언어를 쉽게 배우고 사용해보고 즐겼으면 좋겠다는 생각으로 제가 처음에 루비와 루비온레일스 웹 프레임워크를 공부하면서 봤던 자료들을 공유하고자 합니다. <!-- more --> <br/>
그냥 개인적인 취향 문제이니 여기 자료들이 어떤 분들에게는 &lsquo;좋은&rsquo; 자료들이 아닐 수 있다는 것을 명심하시고 특히 어떤 책을 봐서 어떻게 공부했다는 그냥 지표로 삼으시고 자신만의 방법으로 익히고 배워나가시면 됩니다. 프로그래밍 배우기 제일 좋은 방법은 만들어보는 것이니깐요. <br/>
아 또 여기에 제가 적어놨다고 해서 제가 그 책을 다 읽어봤다고 착각하시면 안됩니다. 프로그래밍 책을 &lsquo;완독&#8217;하는 건 그렇게 효율적인 방법이 아니라는 개인적인 생각에..(사실 게을러서)</p>

<h2>Ruby</h2>

<h3><a href="http://book.naver.com/bookdb/book_detail.nhn?bid=7054149">루비 프로그래밍 언어(아마추어에서 프로까지)</a></h3>

<p><img src="http://imageshack.us/a/img407/1197/3jsq.png" alt="루비 프로그래밍 언어(아마추어에서 프로까지)" /><br/>
루비 2.0 이 나왔지만 언어의 기본 문법이나 패러다임은 레일스의 그것과는 달리 대동소이해서 버전에 상관없이 학습을 해도 괜찮습니다.<br/>
하지만 <a href="http://www.ruby-lang.org/en/news/2013/06/30/we-retire-1-8-7/">1.8.7 버전에 대한 지원을 공식적으로 종료</a>하였기 때문에 현재 제일 널리 쓰이는 Rails 3.2.x 버전과 맞는 1.9.3 버전을 기준으로 학습을 하는 것을 추천합니다. 보통 루비 언어를 학습할때 추천하는 책은 <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=2625527">곡괭이 책</a>을 추천하는데 굉장히 좋은 책임은 분명하나 언어 습득의 지름길은 풍부한 예제와 토이 프로그램을 만드는 것이라고 생각하기 때문에 위 책을 추천해드립니다.<br/>
해당 책은 텍스트 분석기, 던전 텍스트 어드벤처 게임, 채팅 봇(일종의 심심이) 만들기 예제들이 있어서 루비 언어의 강력한 기능들과 우아한 문법들을 좀 더 와닿게 학습을 할 수 있습니다. 한가지 장담을 못드리는건 전 원서를 읽으면서 공부했었기 때문에 올해 번역이 되어 나온 이 책이 얼마나 번역이 잘되어있는지는.. 읽어보지 않아서 ㅎㅎ;<br/>
&nbsp;</p>

<h3><a href="http://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional-Series/dp/0321584104">Eloquent Ruby</a></h3>

<p><img src="http://imageshack.us/a/img46/9320/rx48.png" alt="Eloquent Ruby" /><br/>
안타깝게도 우리나라에서 루비는 주류 언어가 아니기 때문에 사실 대부분의 자료들이나 책들이 영어로 되어있습니다.(또는 일본어) 해서 원서 자료를 참고해서 공부하는 건 불가피한 것 같습니다. <br/>
이 책은 한마디로 루비 언어의 idiom 에 포커스를 맞춘 책이라고 할 수 있습니다. 어떤 언어의 문법을 배운다고 해서 그 나라 원어민처럼 말할 수 없는데 그 이유는 우리는 그들의 문화와 idiom(관용어)를 이해하지 못하기 때문입니다. 즉, 루비를 좀 더 루비답게 쓰는 법에 대해서 설명하고 있는 책입니다. <br/>
그 장에서 말하려고 하는 주제와 활용, 그리고 실제 필드에서 사용되는 예제를 들어 쉽고 재밌게 쓰여져 있습니다.
&nbsp;</p>

<h3><a href="http://tryruby.org">Try Ruby</a></h3>

<p><img src="http://img38.imageshack.us/img38/9216/x81.png" alt="Try Ruby" /><br/>
루비나 파이썬 같은 인터프리터 언어의 장점 중 하나는 라인 바이 라인으로 코드를 쳐보고 바로 바로 피드백을 볼 수 있다는 장점이 있습니다. 때문에 웹페이지에서 코드를 직접 쳐보고 결과를 확인할 수 있는 웹 서비스들이 많은데 루비 입문자를 위한 대표적인 사이트 중 하나이다. 15분만 있으면 루비를 배운다는 건데 뭐 영어라는 점을 고려해도 얼추 30분안으로 해당 튜토리얼을 다 끝내볼 수 있다. 루비를 설치하지 않고도 빠르고 적은 시간으로 학습을 할 수 있으니 맛보기엔 제일.
&nbsp;</p>

<h3><a href="http://rubymonk.com/">Ruby Monk</a></h3>

<p><img src="http://imageshack.us/a/img19/6961/mscq.png" alt="Ruby Monk" /><br/>
Try Ruby 가 루비 언어를 소개하는 체험판 정도라면 Ruby Monk 는 Try Ruby 와 똑같은 방식으로 좀 더 루비를 제대로 배울 수 있는 온라인 학습 사이트입니다. 얼마전까지 유료 결제를 해야만 :Ascent 코스를 진행할 수 있었는데 지금은 아예 무료로 다 공개하고 있는 것 같네요. 언어 챕터 별 예제를 하나하나 실행해보고 결과를 확인해보면서 학습할 수 있고 챕터에 해당하는 간단한 프로그래밍 문제가 제공되어서 해당 문제를 풀다보면 어느새 루비 언어 활용에 익숙해지는 것을 느낄 수 있습니다. 특히 코드를 실행할 때 마다 Master says 해서 마스터 요다의 명대사나 쿵푸 팬더 시푸 사부의 명대사 등이 나오면서 깨알같은 재미(또는 영어공부)를 느낄 수 있습니다.<br/>
개인적으로 책을 읽을 시간이 없다면 이 사이트를 추천합니다.
&nbsp;</p>

<h3><a href="http://www.codeschool.com/courses/ruby-bits">Code School Ruby bits 1,2</a></h3>

<p><img src="http://imageshack.us/a/img23/7170/h5f2.png" alt="Code School Ruby bits 1,2" /><br/>
Code School 은 루비와 레일스뿐만 아니라 자바스크립트, HTML, CSS 심지어는 IOS 같이 웹에서 Learn by Doing 할 수 있는 서비스입니다. 몇몇개가 무료로 제공되고 있고 subscription 형태의 유료 서비스로서 한달 25$인데 충분히 그 값어치를 하는 것 같습니다. 하나의 파트에 5~8챕터가 구성되어있고 각 챕터만 최소 5분에서 최대 20분까지의 짧은 동영상 강의가 있습니다. 그리고 동영상 강의의 내용으로 웹에서 문제를 풀 수 있도록 시스템이 되어 있어서 설명만 듣고 잘 이해되지 않는 부분에 대해서도 충분히 피드백을 받으면서 학습할 수 있습니다. 영어라서 동영상 강의가 어렵지 않느냐하는 질문이 있을수 있는데 실제로 다른 언어권의 유저가 영어 캡션이라도 달아달라고 요청을 하니 Gregg Pollack 이 설사 영어를 못알아들어도 PPT 만 보더라도 충분히 이해할 수 있도록 디자인되어 있다고 답변을 하였습니다. 실제로 고퀄리티의 PPT 자료를 보면 그 말이 이해가 되실겁니다.
&nbsp;</p>

<h2>Ruby on Rails</h2>

<h3><a href="http://www.insightbook.co.kr/books/programming-insight/%EB%A0%88%EC%9D%BC%EC%8A%A4%EC%99%80-%ED%95%A8%EA%BB%98%ED%95%98%EB%8A%94-%EC%95%A0%EC%9E%90%EC%9D%BC-%EC%9B%B9-%EA%B0%9C%EB%B0%9C">레일스와 함께하는 애자일 웹 개발</a></h3>

<p><img src="http://imageshack.us/a/img89/8642/em9f.png" alt="레일스와 함께하는 애자일 웹 개발" /><br/>
국내에서 3.2.x 버전에 맞춘 책은 이 책이 유일하고 아마 레일스를 학습하고자 하시는 분들은 대부분 이 책을 구입하셨을 겁니다. 인사이트 출판사에서 이번에 개정판을 냈고 ebook 으로도 제공하고 있으니 영어에 약하시는 분들은 무조건 이 책으로 학습하시면 될 것 같습니다. 하지만 제 개인적으로는 이 책(번역판)을 심도있게 보지 못했기 때문에.. 번역이 좋은지는 잘 모르겠네요.
&nbsp;</p>

<h3><a href="http://ruby.railstutorial.org/">Rails Tutorial</a></h3>

<p><img src="http://imageshack.us/a/img835/6688/ulg5.png" alt="Rails Tutorial" /><br/>
영어가 되신다면 전 위 책보다 이 책을 더 추천합니다. 온라인으로 무료로 공개되어있는 레일스 튜토리얼 책인데 최신 트렌드를 잘 반영해서 Step By Step 으로 프로젝트를 진행할 수 있는 문서입니다. 저도 Ruby 도 Rails 도 아무것도 모를때 이 책만 두 번정도 따라하면서 감을 잡았네요. 영어가 생각보다 쉽게 쓰여져있어서 생각보다 수월하게 읽히는 장점이 있습니다. Rails 뿐만 아니라 웹 프로그래밍 입문자를 고려해서 Heroku, Twitter Bootstrap, RSpec 등 다양한 도구와 라이브러리들을 활용해서 트위터와 비슷한 SNS 서비스를 만드는 걸 목표로 하고 있습니다. 챕터1부터 챕터11까지 따라만 가면 Ruby 와 Rails 도 배우고 TDD 도 하고 SNS 서비스 만들어서 Heroku 에 바로 배포까지 하는거죠. 굉장히 강추하는 책입니다. :)
&nbsp;</p>

<h3><a href="http://guides.rubyonrails.org/">Rails Guide</a></h3>

<p><img src="http://imageshack.us/a/img692/813/89tx.png" alt="Rails Guide" /><br/>
루비온레일스 공식가이드입니다. 말이 필요없겠죠? 시간날때마다 하나씩 들여다보면서 공부해보는 것도 나쁘지 않을 정도로 잘 써놓아서 솔직히 정면 돌파하고 싶으신 분들은 이 가이드 사이트 하나만 있어도 문제없을 것 같네요.
&nbsp;</p>

<h3><a href="http://rorlab.org/">RoRlab.org</a></h3>

<p><img src="http://imageshack.us/a/img687/7212/6gi.png" alt="RoRlab.org" /><br/>
최효성 박사님께서 운영하시는 국내 비공식 루비온레일스 Lab 입니다. 원래 직업이 의사이신데 Rails 에 꽂히셔서(?) 지식 기부를 무료로 하시고 오프라인으로도 강남에서 2주에 한번씩 입문자를 위한 세미나를 여시고 계십니다. 교재는 공식 레일스 가이드이고 번역까지 하고 계십니다. 의사라는 분들은 왜이렇게 다재다능한걸까요?(..) 어쨋든 대한민국 루비온레일스 전파에 힘쓰시고 계시고 시간이 되신다면 오프라인 세미나도 들어보시고 같이 공부해나가시면 큰 도움이 되는 곳입니다.
&nbsp;</p>

<h3><a href="http://www.codeschool.com/paths/ruby">Code School Rails</a></h3>

<p><img src="http://imageshack.us/a/img23/7170/h5f2.png" alt="Code School Rails" /><br/>
코드 스쿨의 모든 Rails 코스들은 굉장히 유익한 코스들입니다. 당장 Rails 를 설치하지 않아도 온라인 코스만 따라가도 Rails 전체를 Overview 하기에 부족함없는 코스들인데 저는 Rails for Zombies Redux 빼고는 어느 정도 Rails 개발을 하시는 중간중간에 보시는걸 추천드립니다. 처음에 다 보면서 공부해도 좋지만 와닿지 않을 수 있기때문에 금방 까먹거든요. Rails 기본, 최신 Rails 4, TDD(RSpec, Testunit), Rails Best Practice 까지 추천!
&nbsp;</p>

<h3><a href="http://railscasts.com/">Rails Casts</a></h3>

<p><img src="http://imageshack.us/a/img189/1539/yth9.png" alt="Rails Casts" /><br/>
기본적으로 레일스의 장점 중 하나는 쉽고 빠르게 쓸 수 있는 라이브러리(gem)들을 이용해서 빠르게 웹 애플리케이션 구축을 할 수 있다는 건데요. 그 많은 오픈소스 라이브러리들이 문서가 굉장히 불친절한 경우가 많습니다. 그런 라이브러리들을 빠르게 프로젝트에 적용하도록 도와주는 튜토리얼 문서와 동영상 강의가 있는 곳입니다. 아마 실제 개발을 하게되면 많이 참고하는 사이트 중 하나인 것 같습니다.
&nbsp;</p>

<h3><a href="http://net.tutsplus.com/category/tutorials/ruby/">Nettus+</a></h3>

<p><img src="http://imageshack.us/a/img20/2335/s8wb.png" alt="Nettus+" /><br/>
Nettus+는 여러가지 팁이나 튜토리얼 문서가 올라오는 사이트인데 도움이 되는 실전 예제를 다루는 문서들이 꽤 있습니다. Ruby 뿐만 아니라 다른 언어도 있으니 한번 참고해보세요.</p>

<p>&nbsp;</p>

<h2>Facebook Group</h2>

<h3><a href="https://www.facebook.com/groups/rubykr/">Ruby Korea</a></h3>

<p>국내 대표 Ruby 커뮤니티입니다. Ruby 코딩 도장, Rails 스터디 등이 운영되었으며 현재는 한달에서 세달에 한 번씩 간헐적으로(?) 세미나가 개최됩니다. 오시면 많은 국내 루비스트들을 보실수있죠. 질문이나 정보 공유에도 도움이 많이 되는 곳입니다.
&nbsp;</p>

<h3><a href="https://www.facebook.com/groups/rubyonrailskorea/">Ruby on Rails Korea</a></h3>

<p>RoRlab.org 에서 운영하는 페이스북 페이지입니다. 가입하실려면 자기소개를 준비하는 센스 ^^^;
&nbsp;</p>

<h3><a href="https://www.facebook.com/groups/BeRubyist/">Be a Rubyist</a></h3>

<p>여기에 끼기에는 좀 그렇지만 제가 직접 운영하는 비공식 스터디 그룹입니다. 루비, 레일스, 자바스크립트, 현재는 스칼라까지 하나의 주제로 두 달에서 길면 세 달까지 스터디를 하고 알고리즘 문제를 가지고 TDD 적용해보기, 페어프로그래밍해보기, 해커톤 등 여러 시도를 하면서 재밌게 스터디를 하고 있는 곳입니다. 매주 토요일 오전 10시에 구로디지털단지역 쪽에서 스터디를 하구 있구요. 다음 스터디 모집때 공지하면 많은 분들이 참여해주시면 좋을 것 같네요:)</p>

<p>&nbsp;</p>

<h2>Conclusion</h2>

<p>어떤 언어나 프레임워크나 그것을 빠르게 익히기 위해서는 Learn by Doing 하는 것이 지름길이라고 생각합니다. 그래서 그렇게 공부할 수 있는 리소스들을  추천을 해놓았구요. 좀 더 좋은 리소스와 자료들이 있으면 한국 루비 개발 생태계를 위해 공유해주시면 더 좋을 것 같습니다. 읽어주셔서 감사합니다.</p>

<p><img src="http://imageshack.us/a/img689/38/6bj0.png" alt="Ruby is.." /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala 스터디 회고 및 발표 자료]]></title>
    <link href="http://flowkater.github.io/blog/2013/08/03/scala-study-resource/"/>
    <updated>2013-08-03T17:40:00+09:00</updated>
    <id>http://flowkater.github.io/blog/2013/08/03/scala-study-resource</id>
    <content type="html"><![CDATA[<p>현재 <a href="https://www.facebook.com/groups/BeRubyist/">Be a Rubists</a> 스터디에서 <a href="http://bjpublic.tistory.com/158">쉽게 배워서 빨리 써먹는 스칼라 프로그래밍</a> 스칼라 스터디를 진행하고 있습니다. 관련 발표자료를 공유하고 추후 자료를 더 보강해서 계속해서 업데이트 하겠습니다. <!-- more --></p>

<p>&nbsp;
매주 스터디를 진행하면서 회고를 작성중입니다. 스터디 참여 멤버분들의 피드백과 개선점, 느낌점을 그날그날 기록하여 스터디에 반영하도록 노력하고 있습니다.
<a href="https://github.com/flowkater/ProjectEuler_kr/tree/master/scala">스칼라 스터디 회고</a></p>

<h2>스칼라 스터디 오리엔테이션 &ndash; 발표자 서병선님</h2>

<script async class="speakerdeck-embed" data-id="e2608900de430130c1220eac3c9ba422" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>스칼라 배열 사용하기 &ndash; 발표자 봉성주님</h2>

<script async class="speakerdeck-embed" data-id="4352ef50de450130500d1eb25ece1fde" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>스칼라 맵과 튜플 &ndash; 발표자 이경욱님</h2>

<script async class="speakerdeck-embed" data-id="5b7d2cc0de450130c1230eac3c9ba422" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>스칼라 클래스 &ndash; 발표자 김지원님</h2>

<script async class="speakerdeck-embed" data-id="43a50850dee101300cb91a5bfdd09542" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>스칼라 오브젝트 &ndash; 발표자 최민기님</h2>

<script async class="speakerdeck-embed" data-id="7b0b7270de45013064152292094fcb41" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>스칼라 패키지와 임포트 &ndash; 발표자 최민기님</h2>

<script async class="speakerdeck-embed" data-id="8fbc7d00de4501309e464266729d3f42" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>스칼라 상속 &ndash; 발표자 서병선님</h2>

<script async class="speakerdeck-embed" data-id="aa33eb00de450130500d1eb25ece1fde" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>스칼라 파일과 정규표현식 &ndash; 발표자 이경욱님</h2>

<script async class="speakerdeck-embed" data-id="bdeac460de45013027707a89a736d299" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>스칼라 Trait &ndash; 발표자 조재우(flowkater)</h2>

<script async class="speakerdeck-embed" data-id="d341cc10de45013064162292094fcb41" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<p><em><small><a href="https://www.facebook.com/groups/BeRubyist/" title="루비스트가 되자">Be a Rubyist</a> 페이스북 그룹에서 매주 토요일 오전 10시부터 오후 1시까지 모여서 같이 스칼라 스터디를 진행중입니다. 해커톤, 알고리즘 문제 페어 프로그래밍 등 단순한 북스터디 이상으로 시행착오를 겪으면서 7개월 넘게 운영되고 있는 스터디입니다. 관심있으신 분들은 많은 참여부탁드립니다. :) </small></em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[자바스크립트 핵심가이드 스터디 발표 자료]]></title>
    <link href="http://flowkater.github.io/blog/2013/05/30/javascript-study-resource/"/>
    <updated>2013-05-30T11:06:00+09:00</updated>
    <id>http://flowkater.github.io/blog/2013/05/30/javascript-study-resource</id>
    <content type="html"><![CDATA[<p>현재 스터디에서 <a href="http://www.hanb.co.kr/book/look.html?isbn=978-89-7914-598-4">자바스크립트 핵심가이드</a> 스터디를 하고 있는데 어제 스터디를 마지막으로 책 스터디가 마무리되었습니다. 관련 발표자료를 공유하고 추후 자료를 더 보강해서 계속해서 업데이트 하겠습니다.</p>

<!-- more -->


<h2>자바스크립트 오리엔테이션 &ndash; 발표자 조재우(flowkater)</h2>

<script async class="speakerdeck-embed" data-id="45b52d10aafe0130da893e97780925f0" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>자바스크립트 awful&amp;bad parts &ndash; 발표자 조재우(flowkater)</h2>

<script async class="speakerdeck-embed" data-id="f2709f70aafd0130f3382e483e3562d4" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>자바스크립트 Array &ndash; 발표자 서병선님</h2>

<script async class="speakerdeck-embed" data-id="cf438620aaff0130efd95a101b549cb4" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>자바스크립트 Style &ndash; 발표자 이수영님</h2>

<script async class="speakerdeck-embed" data-id="f77aac50b08f0130dda932ae863805fe" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<p><em><small><a href="https://www.facebook.com/groups/BeRubyist/" title="루비스트가 되자">Be a Rubyist</a> 페이스북 그룹에서 <a href="http://euler.synap.co.kr/">오일러 프로젝트</a> 를 매주 수요일 저녁 7시에 모여서 같이 <a href="http://xper.org/wiki/xp/PairProgramming">페어프로그래밍</a>을 하면서 풀어나가고 있습니다. 관심있으신 분 참여해주세요! 지금은 자바스크립트, 클라이언트 프레임워크 스터디가 진행 중입니다.</small></em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby, Rails 스터디 이전 발표 자료]]></title>
    <link href="http://flowkater.github.io/blog/2013/05/29/be-a-rubyist-1-2/"/>
    <updated>2013-05-29T11:51:00+09:00</updated>
    <id>http://flowkater.github.io/blog/2013/05/29/be-a-rubyist-1-2</id>
    <content type="html"><![CDATA[<p>그때 그때마다 발표자료를 백업해놨어야됬는데 많이 사라졌네요. 이전 발표자 분들에게 다시 보내달라고 요청은 했으나 언제 전부 업데이트 할 수 있을지..
일단 현재 남아있는 자료만 올리겠습니다.</p>

<!-- more -->


<h2>Be A Rubyist 해카톤 준비 전 간단한 경험 공유 &ndash; 발표자 조재우(flowkater)</h2>

<script async class="speakerdeck-embed" data-id="fbb1c380aaff01306d5d2af1e312ded6" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>Rails Active Record 에 관한 발표 &ndash; 발표자 김지원님</h2>

<script async class="speakerdeck-embed" data-id="a6578c00ab0001306d5d2af1e312ded6" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>Rails Migration 에 대한 발표 &ndash; 발표자 변준호님</h2>

<script async class="speakerdeck-embed" data-id="78e995b0af230130af6d7eed166d7b22" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>Rails Asset Pipeline 에 대한 발표 &ndash; 발표자 김명회님</h2>

<script async class="speakerdeck-embed" data-id="a2edf830b3110130f4f676ca31124ae6" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<h2>Ruby &ndash; Data &amp; Object 요약 발표 &ndash; 발표자 임영수님</h2>

<script async class="speakerdeck-embed" data-id="63c4fb20ab1f01303283324ccc551f9a" data-ratio="1.33333333333333" src="http://flowkater.github.io//speakerdeck.com/assets/embed.js"></script>


<p>&nbsp;</p>

<p><em><small><a href="https://www.facebook.com/groups/BeRubyist/" title="루비스트가 되자">Be a Rubyist</a> 페이스북 그룹에서 <a href="http://euler.synap.co.kr/">오일러 프로젝트</a> 를 매주 수요일 저녁 7시에 모여서 같이 <a href="http://xper.org/wiki/xp/PairProgramming">페어프로그래밍</a>을 하면서 풀어나가고 있습니다. 관심있으신 분 참여해주세요! 지금은 자바스크립트, 클라이언트 프레임워크 스터디가 진행 중입니다.</small></em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[최적화된 에라토스테네스의 체 (Optimized Sieve of Erathosthenes)]]></title>
    <link href="http://flowkater.github.io/blog/2013/04/08/coejeoghwadoen-eratoseuteneseuyi-ce-optimized-sieve-of-erathosthenes/"/>
    <updated>2013-04-08T13:32:00+09:00</updated>
    <id>http://flowkater.github.io/blog/2013/04/08/coejeoghwadoen-eratoseuteneseuyi-ce-optimized-sieve-of-erathosthenes</id>
    <content type="html"><![CDATA[<p><em><small>현재 <a href="https://www.facebook.com/groups/BeRubyist/" title="루비스트가 되자">Be a Rubyist</a> 페이스북 그룹에서 <a href="http://euler.synap.co.kr/">오일러 프로젝트</a> 를 매주 수요일 저녁 7시에 모여서 같이 <a href="http://xper.org/wiki/xp/PairProgramming">페어프로그래밍</a>을 하면서 풀어나가고 있습니다. 관심있으신 분 참여해주세요!</small></em></p>

<p>알고리즘에 관한 첫 포스팅인데 오늘은 <a href="http://ko.wikipedia.org/wiki/%EC%86%8C%EC%88%98">소수</a> 판별법에 대해서 얘기를 해볼까 합니다. 초기 알고리즘 문제를 접하면 가장 많이 접하는 문제인데 그 중 한 방법인 <a href="http://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4">에라토스테네스의 체</a>라는 방법을 알아보겠습니다. 그 전에 이 방법을 고민하게 만들었던 오일러 프로젝트의 문제를 한번 살펴보겠습니다. <!-- more --></p>

<h2>Problem 10</h2>

<p><em>10 이하의 소수를 모두 더하면 2 + 3 + 5 + 7 = 17 이 됩니다. 이백만(2,000,000) 이하 소수의 합은 얼마입니까?</em></p>

<p>굉장히 심플한 문제이고 n 이 소수인지 아닌지 판별하기 위해서 가장 심플한 아이디어는 2부터 n-1 까지 모든 수를 나눠서 나눠지는 숫자가 없으면 소수입니다. 간단히 볼까요?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">is_prime?</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="mi">2</span><span class="o">.</span><span class="n">.n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">each</span><span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span>
</span><span class='line'>  <span class="kp">true</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>하지만 이런 식으로 판별을 하게 될 경우 2,000,000 까지 모든 숫자를 확인한다면 시간은 굉장히 오래걸리게 됩니다. 그럼 이걸 어떻게 좀 더 최적화할 수 있을까요? 바로 다음 정리를 이용해서 시간을 줄일 수 있습니다.</p>

<h3>정리1</h3>

<p><em>1 보다 큰 자연수 n 에 대하여 √n 보다 작거나 같은 모든 소수가  n을 나누지 못하면 n은 소수이다.</em></p>

<h3>증명</h3>

<p><small><em>증명은 대우와 귀류법을 통해서 증명할 수 있습니다.</em></small></p>

<ul>
<li><small>대우명제를 부정 &ndash;> n이 합성수이면 n은 √n보다 작거나 같은 약수를 갖지 않는다.</small></li>
<li><small>n= a * b ( a, b 는 양의정수이고 1이 아니다)</small></li>
<li><small>가정에 의하면 2 ≤ a ≤ b &lt; n 이다.</small></li>
<li><small>a > √n, b > √n 이면 a * b > √n * √n 인데 이때, <em>n > n => 여기서 모순이 발생한다.</em></small></li>
</ul>


<blockquote><p><strong>따라서 n이 소수가 아니라면 n의 약수 중에서 √n보다 작거나 같은 소수가 존재한다. 그러므로 자연수 n이 √n 이하의 어떤 소수로도 나누어 떨어지지 않으면 n 은 소수이다.</strong></p></blockquote>

<p>이와 같은 방식으로 다시 코드를 보면</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">is_prime?</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="mi">2</span><span class="o">.</span><span class="n">.</span><span class="no">Math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">))</span><span class="o">.</span><span class="n">each</span><span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span>
</span><span class='line'>  <span class="kp">true</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>시간 복잡도는 n-1에서 √n 으로 줄어드는 것을 알 수 있습니다.</p>

<p>하지만 여전히 2,000,000개의 모든 숫자를 체크하기에는 실행속도가 꽤 오래걸리는데, 소수 판별법에도 여러가지 방법이 있는데 n 까지의 소수를 구하는 방법 중 가장 고전적인 방법인 <a href="http://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4">에라토스테네스의 체</a> 방법을 이용해보기로 했습니다. 이 방법의 아이디어도 굉장히 심플합니다.</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif" alt="에라토스체이미지" /></p>

<p>위 그림을 보면 간단히 이해가 될 것입니다. <em>2부터 (1은 소수가 아니므로) n 까지 모든 숫자를 배열에 넣고 차례대로 배열의 존재 유무를 체크합니다. 그리고 배열이 존재하면 또다른 배열에다가 담고 해당 배열 인덱스의 배수는 모두 삭제합니다. 이 방법으로 해나가다보면 위와 같이 120까지의 모든 소수를 구할 수 있게 됩니다.</em></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">sum_of_primes</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span><span class='line'>  <span class="n">sieve</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span> <span class="c1"># n 까지 true 로 배열</span>
</span><span class='line'>  <span class="n">sieve</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kp">false</span><span class="p">;</span> <span class="n">sieve</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kp">false</span> <span class="c1"># 0, 1 은 소수가 아니므로</span>
</span><span class='line'>  <span class="p">(</span><span class="mi">2</span><span class="o">.</span><span class="n">.n</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>    
</span><span class='line'>      <span class="p">(</span><span class="mi">2</span><span class="o">.</span><span class="n">.n</span><span class="p">)</span><span class="o">.</span><span class="n">each</span><span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="k">if</span> <span class="n">x</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="k">then</span> <span class="n">sieve</span><span class="o">[</span><span class="n">x</span><span class="o">*</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kp">false</span> <span class="k">else</span> <span class="k">break</span> <span class="k">end</span><span class="p">}</span> <span class="k">if</span> <span class="n">sieve</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="c1"># 해당 인덱스가 true 이면 그 배수는 모두 false</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">primes</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'>  <span class="p">(</span><span class="mi">2</span><span class="o">.</span><span class="n">.n</span><span class="p">)</span><span class="o">.</span><span class="n">each</span><span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">primes</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="k">if</span> <span class="n">sieve</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">}</span> <span class="c1"># true 인 인덱스만 배열에 입력</span>
</span><span class='line'>  <span class="n">primes</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="ss">:+</span><span class="p">)</span> <span class="c1"># 소수들의 합을 반환</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>그런데 이렇게 하는게 처음 방법보다 훨씬 효율적이지는 않습니다. 해당 코드를 정리1을 응용해서 조금 더 개선시킬 수 있습니다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">sum_of_primes</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span><span class='line'>  <span class="n">sieve</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
</span><span class='line'>  <span class="n">sieve</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kp">false</span><span class="p">;</span> <span class="n">sieve</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kp">false</span>
</span><span class='line'>  <span class="p">(</span><span class="mi">2</span><span class="o">.</span><span class="n">.</span><span class="no">Math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">floor</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>  <span class="c1"># √n까지만 구하면 배수는 모두 제거된다.</span>
</span><span class='line'>      <span class="p">(</span><span class="mi">2</span><span class="o">.</span><span class="n">.n</span><span class="p">)</span><span class="o">.</span><span class="n">each</span><span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="k">if</span> <span class="n">x</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="k">then</span> <span class="n">sieve</span><span class="o">[</span><span class="n">x</span><span class="o">*</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kp">false</span> <span class="k">else</span> <span class="k">break</span> <span class="k">end</span><span class="p">}</span> <span class="k">if</span> <span class="n">sieve</span><span class="o">[</span><span class="n">x</span><span class="o">]</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">primes</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'>  <span class="p">(</span><span class="mi">2</span><span class="o">.</span><span class="n">.n</span><span class="p">)</span><span class="o">.</span><span class="n">each</span><span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">primes</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="k">if</span> <span class="n">sieve</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">}</span>
</span><span class='line'>  <span class="n">primes</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="ss">:+</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>다시 위 에니메이션을 눈여겨 본다면, √120, 즉 10.xxx 전까지의 숫자의 배수만 체크하면 나머지는 모두 소수라는 것을 알게 됩니다.</p>

<p>이로써 조금 더 개선이 되었습니다. 하지만 우리는 소수 중 <em>2</em>에 주목할 필요가 있는데 이 소수는 소수 중에 유일한 짝수가 됩니다.</p>

<p>즉 2를 제외한 나머지 소수는 모두 홀수라는 거죠. 제일 처음 2를 체크하여 2의 배수를 제거하는 작업을 하는데 이때 n = 2,000,000 이라면 이것도 꽤나 시간이 걸리는 작업입니다.
그래서 아예 처음에 배열을 반토막 낸 상태에서 초기화하고 나중에 인덱스를 맞춰서 배열에 넣어주면 훨씬 더 작업속도가 빨라지는 것을 알 수 있습니다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">sum_of_primes_opt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span><span class='line'>  <span class="n">sieve</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span> <span class="p">(</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span> <span class="c1"># 반토막 낸다. (홀수만 고려)</span>
</span><span class='line'>  <span class="mi">3</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="no">Math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">floor</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="c1"># 3부터 2step 씩 (3,5,..) </span>
</span><span class='line'>      <span class="k">next</span> <span class="k">unless</span> <span class="n">sieve</span><span class="o">[</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">]</span> <span class="c1"># 홀수만 고려해서 i 가 인덱스를 참조하기 때문에 반토막 낸 모든 배열 인덱스에 접근하기 위해 2를 나눠줌</span>
</span><span class='line'>                     <span class="c1"># 역시 false 이면 next </span>
</span><span class='line'>      <span class="p">(</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">)</span><span class="o">.</span><span class="n">step</span><span class="p">(</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">){</span> <span class="o">|</span><span class="n">j</span><span class="o">|</span> <span class="n">sieve</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kp">false</span><span class="p">}</span> <span class="c1"># i의 배수를 모두 false 로 만드는 작업, 2부터 시작하면 짝수를 가리키는데 짝수는 고려하지 않으니 3부터.</span>
</span><span class='line'>                                   <span class="c1"># 역시 반토막 낸 배열에 접근하기 위해서 2를 나눠줌. i 의 배수이기 때문에 step 이 i 만큼 증가.</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">primes</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="c1"># 홀수만 고려했기 때문에 2를 배열에 초기화</span>
</span><span class='line'>  <span class="mi">1</span><span class="o">.</span><span class="n">upto</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
</span><span class='line'>      <span class="k">next</span> <span class="k">unless</span> <span class="n">sieve</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
</span><span class='line'>      <span class="n">primes</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># true 인 인덱스에 접근해서 원래 인덱스로 변환 (홀수로 변환)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="n">primes</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="ss">:+</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>위와 같이 코드를 작성하면 좀 더 최적화가 되었습니다. 실행속도를 비교를 해볼까요?</p>

<h3>sum_of_isprime</h3>

<p>실행속도: 42.xx sec
<img src="http://img854.imageshack.us/img854/1794/sumofisprime.png" alt="sum_of_isprime" /></p>

<h3>sum_of_primes</h3>

<p>실행속도: 0.94xx sec
<img src="http://imageshack.us/a/img39/975/sumofprimes.png" alt="sum_of_primes" /></p>

<h3>sum_of_primes_opt</h3>

<p>실행속도: 0.30xx sec
<img src="http://imageshack.us/a/img713/9319/sumofprimesopt.png" alt="sum_of_primes_opt" /></p>

<p>sum_of_isprime 은 위에서 정리1을 이용한 is_prime? 메서드를 이용해서 소수인지 판별 후 배열에 넣고 합을 구하는 메서드입니다. 실행속도가 굉장히 오래 걸리죠?</p>

<p>sum_of_primes 에 비해서 sum_of_primes_opt 는 3배 정도 빨라졌네요. 마지막으로 sum_of_primes_opt 메서드를 리팩토링 해보겠습니다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">sum_of_primes_opt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span><span class='line'>  <span class="n">primes</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">]</span>
</span><span class='line'>  <span class="n">sieve</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
</span><span class='line'>  <span class="mi">3</span><span class="o">.</span><span class="n">step</span><span class="p">(</span> <span class="no">Math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">floor</span><span class="p">,</span> <span class="mi">2</span><span class="p">){</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="k">if</span> <span class="n">sieve</span><span class="o">[</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="o">]</span> <span class="k">then</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">j</span><span class="o">|</span> <span class="n">sieve</span><span class="o">[</span><span class="n">j</span><span class="o">]=</span><span class="kp">false</span><span class="p">}</span> <span class="k">else</span> <span class="k">next</span> <span class="k">end</span><span class="p">}</span>
</span><span class='line'>  <span class="mi">1</span><span class="o">.</span><span class="n">upto</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">){</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="k">if</span> <span class="n">sieve</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="k">then</span> <span class="n">primes</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">else</span> <span class="k">next</span> <span class="k">end</span><span class="p">}</span>
</span><span class='line'>  <span class="n">primes</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="ss">:+</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><small>루비로 코딩을 하면서 제일 재밌는 부분이 바로 코드를 줄일수 있을때까지 줄여보는 재미인 것 같습니다. block 은 위대합니다..</small></p>

<p>소수 판별법은 이 외에도 굉장히 여러가지가 있으며 각각에 다양한 수학적 증명도 존재합니다. <a href="http://euler.synap.co.kr/">오일러 프로젝트</a>의 문제를 풀다보면 소수 관련 문제가 많이 있는데요. 앞으로 또 풀어보면서 다양한 소수판별법으로 접근해서 풀이를 해보기로 하겠습니다. 읽어주셔서 감사합니다.</p>

<p><small><em>참고</em></small></p>

<ul>
<li><small><a href="http://soyoja.com/160">soyojas님의 소수구하기알고리즘</a></small></li>
<li><small><a href="http://blog.naver.com/PostView.nhn?blogId=cky5122&amp;logNo=80170123656&amp;categoryNo=162&amp;parentCategoryNo=-1&amp;viewDate=&amp;currentPage=&amp;postListTopCurrentPage=&amp;isAfterWrite=true">조가희님의 소수 판별 알고리즘 시간 복잡도 분석</a></small></li>
<li><small><a href="http://hisjournal.net/blog/128">6l4ck3y3님의 소수판별알고리즘최적화</a></small></li>
<li><small><a href="http://sirini.net/blog/737">시리니님의 소수판별알고리즘</a></small></li>
</ul>

]]></content>
  </entry>
  
</feed>
